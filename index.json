[
{
	"uri": "https://echebbi.github.io/ale-lang-docs/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Getting Started Install ALE and run a simple Hello World project.\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/getting-started/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Install ALE from its update site 1. Install Eclipse IDE The recommended package is Eclipse IDE for Java and DSL developers.\n2. Install Sirius 6.0.0  Open Eclipse IDE Go to Help \u0026gt; Install New Software... Copy Sirius 6.0.0 update site\u0026rsquo;s URL in the Work with textbox  http://download.eclipse.org/sirius/updates/releases/6.0.0/photon/   Hit Enter and wait for the list to load Check Sirius Core Runtime Click Next and Finish  3. Install ALE  Open Eclipse IDE Go to Help \u0026gt; Install New Software... Copy the update site\u0026rsquo;s URL in the Work with textbox  http://www.kermeta.org/ale-lang/updates/latest/   Hit Enter and wait for the list to load Check Action Language for EMF Click Next and Finish Restart the IDE  You are ready to go!\nInstall other versions Archived versions  Archived versions of ALE can be found at the following URL: http://www.kermeta.org/ale-lang/updates/  Nightybuilt versions  Latest version built by the continuous integration is available at: https://ci.inria.fr/gemoc/job/ale-lang/job/master/lastSuccessfulBuild/artifact/releng/org.eclipse.emf.ecoretools.ale.updatesite/target/repository/  To install a version:\n Pick its URL (which is in the form http://www.kermeta.org/ale-lang/updates/yyyy-mm-dd/) Use it in Eclipse IDE as explained above.  "
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/reference/file-extensions/",
	"title": "File extensions",
	"tags": [],
	"description": "",
	"content": "This chapter presents all the files used to configure ALE.\n DSL file (.dsl) This file describes a Domain Specific Language (DSL) made executable with ALE. Its file extension is dsl.\nIt defines both the abstract syntax (Ecore models) and the semantics (ALE source files) of the DSL.\nIt is a standard Java properties file (i.e. a textual file where each line follows the syntax key=value)\nA typical DSL files contains the following entries:\n   Key Value     syntax A comma separated list of paths to .ecore files   behavior A comma separated list of paths to .ale files    Examples: \r\rlogo-standalone.dsl\r\r\rsyntax=../logo.model/model/ASMLogo.ecore,../logo.model/model/VMLogo.ecore\rbehavior=../logo.example/data/LogoProgram.ale\r\r\r \r\rlogo.dsl\r\r\rsyntax=platform:/resource/logo.model/model/ASMLogo.ecore,platform:/resource/logo.model/model/VMLogo.ecore\rbehavior=platform:/resource/logo.example/data/LogoProgram.ale\r\r\r Eclipse Platform URL schemes are also supported, which eases the location of files within a workspace: platform:/resource/\u0026lt;project\u0026gt;/\u0026lt;source_file.ale\u0026gt;\n\r Behavior file (*.ale) This file defines a DSL implementation (i.e. its semantics).\nIt allows to re-open EClass from the abstract syntax to mainly implements existing EOperations but also to declare new ones, new features and even new classes specific to the runtime.\nIt uses the file extension ale. The file must start with behavior \u0026lt;unique identifier\u0026gt;. Example: \r\rfsm.ale\r\r\rbehavior fsm.implementation;\ropen class FSM {\roverride void exec() {\r// Do stuff\r}\r}\rclass Variables {\r// Store values here\r}\r\r\r "
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/tutorials/mini-fsm/",
	"title": "Mini-FSM Tutorial",
	"tags": [],
	"description": "",
	"content": "Objectives  Learn how to make an Ecore model executable.  This is not a tutorial about EMF and some basic knowledge is expected. You can learn more about EMF on Vogella or on EclipseSource\n\rIntroduction For this first tutorial we\u0026rsquo;ll implement a simple FSM. So, what is it?\nWikipediaâ€™s definition:\n [A FSM] is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. A FSM is defined by a list of its states, its initial state, and the conditions for each transition.\n Basically, it is a system which can be in different states, which behaves differently according to its current state and transition from one state to another upon certain events.\n1. Import the minifsm example project The minifsm example project defines a simple FSM metamodel with no behavior. To import it in the workspace:\n File \u0026gt; New \u0026gt; Example... EcoreTools ALE Examples \u0026gt; Tutorials Select minifsm Finish  The metamodel defined in this project is the following:\nWe are now going to define its behavior.\nThe Sirius integration provides handy features to both visualize and edit behavioral elements directely from a Sirius representation.\n\r2. What do we want? Let\u0026rsquo;s pause for a moment and think about what we want to achieve exactly. Basically, we have the following behaviors to implement:\n state to state transition state execution  3. Behavior implementation First of all, to check whether a transition can be activated we have to keep track of the current event. Open the minifsm.ale file and add a currentEvent attribute to FSM:\nbehavior minifsm;\ropen class FSM {\rString currentEvent;\r}\rWe can now implement Transition.isActivated as follows:\nopen class Transition {\roverride boolean isActivated() {\rboolean isRelatedToCurrentState := self.incoming = self.fsm.currentState\rboolean isExpectedEvent := self.fsm.currentEvent = self.event;\rresult := isRelatedToCurrentState and isExpectedEvent;\r}\r}\rWe are checking that:\n the event triggered by the Transition is the same as the current event handle by the FSM, the incoming State from the Transition is the current State of the FSM.  The content of the variable result will be returned at the end of isActivated.\nThe variable self refers to the current object (here it is a Transition).\nIn a similar way we implement State.execute:\nopen class State {\roverride void execute() {\r(' Execute ' + self.name).log();\r}\r}\rThe log method is used to print an object.\nAnd for the implementation of FSM.handle:\nopen class FSM {\roverride void handle (EString event) {\r(' Handle ' + event).log();\rself.currentEvent := event;\rself.currentState :=\rself.transitions\r-\u0026gt;select(t | t.isActivated())\r-\u0026gt;first()\r.outgoing;\r}\r}\rHere we simply update currentEvent, search for an activated Transition and update currentState accordingly.\n4. Entry point definition To complete the behavior of our language, we will now define an entry point to run an FSM.\nCreate a new method annotated with @main in FSM:\nopen class FSM {\r@main\rdef void run() {\r}\r}\rThe main tag indicates that this method will be automatically called when executing an FSM.\nHere we will create a sequence of 2 events, initialize FSM\u0026rsquo;s current state with an initial state and then forward the events to the FSM:\nopen class FSM {\r@main\rdef void run() {\r'Start'.log();\rSequence(String) events := Sequence{'event1','event2'};\rself.currentState :=\rself.states\r-\u0026gt;select(s | s.oclIsKindOf(minifsm::InitialState))\r-\u0026gt;first();\rself.currentState.execute();\rfor(event in events) {\rself.handle(event);\rself.currentState.execute();\r}\r'End'.log();\r}\r}\rThe complete example should look as follows:\n5. Create a dynamic instance Before testing our implementation we need an actual FSM model:\n Select Dynamic \u0026gt; Dynamic instance Click on FSM Name it FSM.xmi and click Finish In the automatically opened FSM.xmi, right click on FSM and select New Child \u0026gt; States Initial State Name it First in the Properties view Create a child State named Second and a Final State named Third Create a Transition and edit the properties Event to event1, Incoming to First and Outgoing to Second Add another Transition from Second to Third with event2  Your FSM model should look like:\n6. Run! Now we can test!\n Right click on minifsm.dsl Select Run As \u0026gt; ALE launch Enter *xmi Select FSM.xmi Then click OK  Console output:\nRun minifsm.dsl\r------------\rStart\rExecute First\rHandle event1\rExecute Second\rHandle event2\rExecute Third\rEnd\rConclusion Congratulations, you created an executable language from scratch!\nGiven an Ecore metamodel you implemented its EOperations with ALE and you run it on an FSM model.\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/features/sirius-integration/",
	"title": "Sirius integration",
	"tags": [],
	"description": "",
	"content": "Behavior layer ALE provides a Sirius layer called Behavior that enhances Sirius representations with attributes and methods defined in ALE source files.\nTo activate this layer:\n Right-click on the representation file (.aird) and select Viewpoints Selection Check Behavior then validate  It can now be shown from the toolbar of the diagram representation: // TODO: add an animated GIF to show the feature in action\nBehavior tools Not fully implemented yet.\n\rWhen the Behavior layer is activated the palette is enhanced with new tools:\nUse these tools to add runtime elements directly from the Sirius representation.\n// TODO: add an animated GIF to show the feature in action\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/features/",
	"title": "Features",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Features Learn about the features provided by ALE.\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/getting-started/hello-world/",
	"title": "Hello World!",
	"tags": [],
	"description": "",
	"content": "Requirements  Have at least a basic knowledge of EMF (Eclipse Modeling Framework). Have installed ALE.  Objectives  Discover the structure of an ALE project through a built-in example. Launch your first ALE program.  Get the HelloWorld example ALE provides an Hello world! project template:\n File \u0026gt; New \u0026gt; Example... EcoreTools ALE Examples \u0026gt; Hello world! Select helloworld Finish  After a few seconds a new project called helloworld should be created in your workspace. This project defines a simple HelloWorld EClass able to print \u0026ldquo;Hello world!\u0026quot;. The content of the project is presented below.\nWhat we have inside The interesting files of the helloworld project are inside the model folder:\n   File Defines     HelloWorld.aird Graphical representation of HelloWorld.ecore   HelloWorld.ale Behavior of HelloWorld.ecore   HelloWorld.dsl Binding between the metamodel (HelloWorld.ecore) and its behavior (HelloWorld.ale)   HelloWorld.ecore Metamodel describing the EClass HelloWorld   HelloWorld.xmi Executable instance of the EClass HelloWorld    By opening HelloWorld.aird you will see the HelloWorld EClass and its properties:\nAs you can see, all the members of HelloWorld are displayed in a bold font. That indicates that they are defined inside HelloWorld.ale.\nIf the members are not shown make sure that the Behavior layer is activated.\n\rHelloWorld.ale contains the following code:\nbehavior HelloWorld;\ropen class HelloWorld { // 1\rString msg := 'Hello world!'; // 2\roverride EString greeting() { // 3\rresult := self.msg; // 4\r}\r@main // 5\rdef void main() {\rself.greeting().log(); // 6\r}\r}\râ‘  Indicate that we modify the HelloWorld EClass. â‘¡ Declare a new attribute of type String. Defining msg within HelloWorls.ale makes it a runtime data. In other words, it does not exist in the metamodel and will be created by the ALE interpreter during the execution.\râ‘¢ Specify the behavior of the greeting operation.\râ‘£ Return the value of the msg attribute (there is no return statement in ALE).\râ‘¤ Indicate that the main operation is the entry point of the execution and should be called by the ALE interpreter.\râ‘¥ Print \"Hello world!\".\r\rSee the Reference chapter for a detailed overview of ALE\u0026rsquo;s syntax.\n\rRun! The execution can be launched through the contextual menu:\n Right-click on HelloWorld.dsl Select Run As \u0026gt; ALE launch, a dialog should open asking you to select the model to interpret Make sure HelloWorld.xmi is selected then click on OK. Witness the result on the console:  Run helloworld.dsl\r------------\rHello world!\rConclusion You should now have an idea of what can be achieved with ALE. Move on the next topic for an overview of ALE\u0026rsquo;s syntax.\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/research/",
	"title": "Research",
	"tags": [],
	"description": "",
	"content": "ALE is the result of research conducted at Inria DiverSE team. It is used to define Domain-Specific Languages (DSLs): the Ecore model and the ALE source files being respectively the abstract syntax and the semantics of those DSLs.\nSee below for a list of related publications.\nPublications Manuel Leduc, Gwendal Jouneaux, Thomas Degueule, Gurvan Le Guernic, Olivier Barais, BenoÃ®t Combemale\nAutomatic generation of Truffle-based interpreters for Domain-Specific Languages\n[preprint]\nManuel Leduc, Thomas Degueule, Benoit Combemale, Tijs van der Storm, Olivier Barais\nRevisiting Visitors for Modular Extension of Executable DSMLs\nIn 2017 ACM/IEEE 20th International Conference on Model Driven Engineering Languages and Systems (MODELS)\n[Publication at IEEE Xplore Digital Library]\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/reference/syntax/",
	"title": "Syntax",
	"tags": [],
	"description": "",
	"content": "Reserved keywords The following table lists ALE\u0026rsquo;s reserved keywords. They cannot be use to name attributes, classes or operations.\n   Keyword Purpose     behavior Defines the semantics\u0026rsquo; namespace   class Declares a new class   def Defines an operation   else Declares a condition statement   extends Declares a class\u0026rsquo; super class   false Represents a false expression   for Iterates on a collection of items   if Declares a conditional statement   null Represents non-existing value   open Enhances an existing class with new features   opposite Indicates that a reference is bidirectional   override Specifies the semantics of an existing operation   self Represents the current instance   true Represents a true expression   unique Indicates that a collection should not contain duplicates   use Imports a Java service    The word result is also reserved inside an operation. See defining operations for further details.\n\rBuilt-in types    Type Description Instantiation     Integer A number without decimal part int a := 12   Real A number with decimal part double r := 23.5   String A sequence of characters String str := 'Hello World!'   Boolean Either true of false boolean b := true   Sequence An ordered collection of elements Sequence(Integer) numbers = Sequence{1, 2, 3}   OrderedSet An ordered collection of unique elements OrderedSet(String) users = OrderedSet{'Foo', 'Bar'}    Looking for types\u0026rsquo; default value? See variable declaration.\n\rOperators Operators on primitive types:\n   Priority Operator Operand Types Syntax Semantic     1 + Numeric \u0026lt;op1\u0026gt; + \u0026lt;op2\u0026gt; Add two numeric values   1 - Numeric \u0026lt;op1\u0026gt; - \u0026lt;op2\u0026gt; Substract two numeric values   2 * Numeric \u0026lt;op1\u0026gt; * \u0026lt;op2\u0026gt; Multiply two numeric values   2 / Numeric \u0026lt;op1\u0026gt; / \u0026lt;op2\u0026gt; Divide \u0026lt;op1\u0026gt; by \u0026lt;op2\u0026gt;   5 += Numeric (\u0026lt;op1\u0026gt; must be a l-value) \u0026lt;op1\u0026gt; += \u0026lt;op2\u0026gt; Set \u0026lt;op1\u0026gt; to \u0026lt;op1\u0026gt; + \u0026lt;op2\u0026gt;   5 -= Numeric (\u0026lt;op1\u0026gt; must be a l-value) \u0026lt;op1\u0026gt; -= \u0026lt;op2\u0026gt; Set \u0026lt;op1\u0026gt; to \u0026lt;op1\u0026gt; - \u0026lt;op2\u0026gt;   5 *= Numeric (\u0026lt;op1\u0026gt; must be a l-value) \u0026lt;op1\u0026gt; *= \u0026lt;op2\u0026gt; Set \u0026lt;op1\u0026gt; to \u0026lt;op1\u0026gt; * \u0026lt;op2\u0026gt;   5 /= Numeric (\u0026lt;op1\u0026gt; must be a l-value) \u0026lt;op1\u0026gt; /= \u0026lt;op2\u0026gt; Set \u0026lt;op1\u0026gt; to \u0026lt;op1\u0026gt; / \u0026lt;op2\u0026gt;   3 \u0026lt; Numeric \u0026lt;op1\u0026gt; \u0026lt; \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is lower than \u0026lt;op2\u0026gt;   3 \u0026gt; Numeric \u0026lt;op1\u0026gt; \u0026gt; \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is greater than \u0026lt;op2\u0026gt;   3 \u0026lt;= Numeric \u0026lt;op1\u0026gt; \u0026lt;= \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is strictly lower than \u0026lt;op2\u0026gt;   3 \u0026gt;= Numeric \u0026lt;op1\u0026gt; \u0026gt;= \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is strictly greater than \u0026lt;op2\u0026gt;   1 + String \u0026lt;op1\u0026gt; + \u0026lt;op2\u0026gt; Concatenate two strings   2 += String (\u0026lt;op1\u0026gt; must be a l-value) \u0026lt;op1\u0026gt; += \u0026lt;op2\u0026gt; Set \u0026lt;op1\u0026gt; to \u0026lt;op1\u0026gt; + \u0026lt;op2\u0026gt;   4 not Boolean not \u0026lt;op\u0026gt; True if \u0026lt;op\u0026gt; is false. False if \u0026lt;op\u0026gt; operand is true   4 and Boolean \u0026lt;op1\u0026gt; and \u0026lt;op2\u0026gt; True if both operands are evaluated to true   4 or Boolean \u0026lt;op1\u0026gt; or \u0026lt;op2\u0026gt; True if at least one of its operands is evaluated to true   4 xor Boolean \u0026lt;op1\u0026gt; xor \u0026lt;op2\u0026gt; True if either \u0026lt;op1\u0026gt; or \u0026lt;op2\u0026gt; is true, but not both   4 implies Boolean \u0026lt;op1\u0026gt; implies \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is false, equals to \u0026lt;op2\u0026gt; otherwise    Operators on collections:\n   Priority Operator Syntax Operand Types Semantic     ? in \u0026lt;item\u0026gt; in \u0026lt;collection\u0026gt; All, Collection Provide an iterator in for loops   ? contains \u0026lt;collection\u0026gt; contains \u0026lt;item\u0026gt; ? True if \u0026lt;item\u0026gt; can be found in \u0026lt;collection\u0026gt;   5 += \u0026lt;collection\u0026gt; += item Collection(T), T Add \u0026lt;item\u0026gt; to \u0026lt;collection\u0026gt;   5 -= \u0026lt;collection\u0026gt; -= item Collection(T), T Remove \u0026lt;item\u0026gt; from \u0026lt;collection\u0026gt;    Global operators:\n   Priority Operator Operand Types Syntax Semantic     3 = All \u0026lt;op1\u0026gt; = \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is equal to \u0026lt;op2\u0026gt; (using Java\u0026rsquo;s equals)   3 != All \u0026lt;op1\u0026gt; != \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is not equal to \u0026lt;op2\u0026gt; (using Java\u0026rsquo;s equals)   3 \u0026lt;\u0026gt; All \u0026lt;op1\u0026gt; \u0026lt;\u0026gt; \u0026lt;op2\u0026gt; True if \u0026lt;op1\u0026gt; is not equal to \u0026lt;op2\u0026gt; (using Java\u0026rsquo;s equals)   5 := All (\u0026lt;op1\u0026gt; must be a l-value) \u0026lt;op1\u0026gt; := \u0026lt;op2\u0026gt; Set \u0026lt;op2\u0026gt; as the value of \u0026lt;op1\u0026gt;    As stated in the Expressions section ALE relies on the AQL interpreter. As a result, most of these keywords are actually AQL keywords.\n\rParenthesis () can be used to change the priority of evaluation:\n2 + 3 * 5 = 17; // true\r(2 + 3) * 5 = 25; // true\rExpressions Expressions are anything that returns a value. For instance:\ntrue // the boolean true\r1 + 5 // 6\risVerbose or isDebug // conditional boolean\r\rExpressions are evaluated thanks to the AQL interpreter and must hence be valid AQL expressions. See AQL for an overview of the language.\n\rComments Simple and multi-line comments Simple line comments start with //:\n// This is a comment\rString name := \u0026quot;Foo\u0026quot;; // This is another comment at the end of a line\rMulti-ligne comments are written between /* and */:\n/* * This comment\r* is on\r* several lines.\r*/\rDocumentation Documentation for classes, attributes and operations can be written between /** and */:\n/**\r* The time before droping the request.\r*/\rint timeoutInMs := 10;\r\rAt the moment this documentation is not leveraged at all.\n\rStatements Statement A statement is an instruction understandable by the ALE interpreter. A statement always ends with a semicolon (;):\nself.greeting().log();\rint length := 12;\rVariable declaration A variable can be declared either within a class or an operation body. It follows the following syntax:\n\u0026lt;type\u0026gt; \u0026lt;var_name\u0026gt; [:= \u0026lt;initial_value\u0026gt;];\r\u0026lt;type\u0026gt; is the type of the variable.\n\u0026lt;var_name\u0026gt; is a unique string identifying the variable. Two different variables with the same name cannot be defined in the same scope.\n\u0026lt;initial_value\u0026gt; is an expression specifying the value of the variable. It must match \u0026lt;type\u0026gt;. It is optional; the following table list the default value given to the variable according to its type:\n   Type Default value     Integer 0   Boolean false   String '\u0026rsquo;   Any other null    \n\r\rExample\r\r\rint localVar; // set to 0\rint otherVar := 2; // set to 2\r\r\r Variable assignment The := operators allows to assign a value to a variable. It follows the following syntax:\n\u0026lt;var_name\u0026gt; := \u0026lt;expression\u0026gt;;\r\u0026lt;var_name\u0026gt; is the identifier used to declare the variable.\n\u0026lt;expression\u0026gt; is the value that must take the variable. It must match the type of the variable.\n\r\rExample\r\r\raString := 'hello';\ranInteger := 42;\r\r\r The assignment operator := must not be confused with the comparison operator = used in expressions.\n\rBlock statement In ALE, the scope of a variable is determined by the block within which it has been declared. A block is defined between { and }.\nCondition statement The if keyword allows to specify a condition before executing a block:\nif (\u0026lt;guard\u0026gt;) {\r// execute if the guard is true\r}\r\u0026lt;guard\u0026gt; is any expression that can be evaluated to true.\n\r\rExample\r\r\rBoolean isRaining := true;\rif (isRaining) {\rself.getFluffyUmbrella();\r}\r\r\r The else keyword allows to execute a block if the guard evaluates to false. else can only be written after the } closing if's block.\n\r\rExample\r\r\rString weather := 'sunny';\rString raining := 'raining';\rif (weather = raining) {\rself.getFluffyUmbrella();\r}\relse {\rself.enjoySunshine();\r}\r\r\r Iteration statement The for keyword allows to execute a block for each element of a collection:\nfor (\u0026lt;item\u0026gt; in \u0026lt;collection\u0026gt;) {\r// executed for each element of the collection\r}\r\u0026lt;item\u0026gt; is the name of a new variable that will take successively the value of each element of the collection. Only accessible within for's block.\n\u0026lt;collection\u0026gt; is an existing variable which multiplicity is greater than 1, such as a sequence or a set.\n\r\rExample\r\r\rSequence(String) names := Sequence{'Foo', 'Bar'};\rfor (name in names) {\rname.log(); // Print \u0026quot;Foo\u0026quot; on the first iteration then \u0026quot;Bar\u0026quot;\r}\r\r\r It is also possible to iterate over a sequence of integers with a range comprehension ([\u0026lt;min\u0026gt;..\u0026lt;max\u0026gt;]):\nfor (i in [1..5]) {\r('' + i).log(); // Print \u0026quot;1\u0026quot;, then \u0026quot;2\u0026quot;, etc.\r}\rLoop statement The while keyword allows to execute a block until a condition is evaluated to false. It follows the following syntax:\nwhile (\u0026lt;condition\u0026gt;) {\r}\r\u0026lt;condition\u0026gt; is any expression that can be evaluated as a boolean.\n\r\rExample\r\r\rwhile (isRaining) {\rself.keepUmbrellaOpened();\r}\r\r\r Classes and operations Creating a new class The class keyword allows to define a new class. It follows the following syntax:\nclass \u0026lt;class_name\u0026gt; {\r}\r\u0026lt;class_name\u0026gt; is a valid Java identifier.\n\r\rExample\r\r\r/**\r* A class that only exists during the runtime.\r*/\rclass State {\r}\r\r\r Unlike open classes, these classes only exist at runtime, when the ALE interpreter is running. Such classes typically do not make sense as part of a model but are useful during the execution (e.g. for state management purposes).\nDefining operations The def keyword allows to define new operations. It follows the following syntax:\ndef \u0026lt;return_type\u0026gt; \u0026lt;op_name\u0026gt;([\u0026lt;param_type\u0026gt; \u0026lt;param_name\u0026gt;]*) {\r}\r\u0026lt;return_type\u0026gt; defines the type of the value returned by the operation.\n\u0026lt;op_name\u0026gt; is a string uniquely identifying the operation.\n\u0026lt;param_type\u0026gt; \u0026lt;param_name\u0026gt; define the type and the name of a parameter. Parameters are optional and separated by commas (,).\nAn operation must be defined within a class body.\n\r\rExample\r\r\ropen class Vector {\rdef int add(int a, int b) {\rresult := self.a + self.b;\r}\r}\r\r\r result is a special variable which is only accessible within an operation body. It stores the result of the operation and is automatically returned at the end of the operation body. As such, it replaces the return keyword used by a lot of programming languages.\nWithin a method, one can refer to the current instance with the self keyword. It allows to access instance\u0026rsquo;s attributes and call instance\u0026rsquo;s operations.\n\r\rExample\r\r\ropen class User {\rdef String fullname() {\rresult := self.firstname + ' ' + self.lastname;\r}\r}\r\r\r Unlike overridden methods, these methods only exist at runtime, when the ALE interpreter is running. Semantically, that means that their are not part of DSL\u0026rsquo;s abstract syntax but are still useful during the development.\nInstanciating an EClass create() is a Java service (see Call Java code) that is automatically added by ALE to every EClass and which allows to create a new instance. It follows the following syntax:\n\u0026lt;class_name\u0026gt; \u0026lt;var_name\u0026gt; := \u0026lt;package_name\u0026gt;::\u0026lt;class_name\u0026gt;.create();\r\u0026lt;class_name\u0026gt; is the Java name of the class to instantiate.\n\u0026lt;var_name\u0026gt; is the name of the variable that stores the new instance.\n\u0026lt;package_name\u0026gt; is the Java package in which the class lies.\n\r\rExample\r\r\rHelloWorld world := helloworld::HelloWorld.create();\r\r\r Importing an existing class The import keyword allows to use classes defined in another file. It follows the following syntax:\nimport \u0026lt;behavior\u0026gt; as \u0026lt;alias\u0026gt;\r\u0026lt;behavior\u0026gt; is the ID of the behavior to which the class belongs.\n\u0026lt;alias\u0026gt; is the name under which the behavior is known in the current file.\n\r\rExample\r\r\rbehavior fsm.composite.executable;\rimport fsm.executable as fsm;\ropen class Start {\r@main\rdef void run()\rfsm.State initial = fsm::State.create();\r}\r}\r\r\r Open Class This chapter binds ALE\u0026rsquo;s syntax with EMF concepts and explains how the ALE script can affect a metamodel at runtime.\n Open classes The open keyword allows to re-open an existing EClass to add new elements and implement existing EOperations. We call such classes: \u0026ldquo;open classes\u0026quot;. It follows the following syntax:\nbehavior \u0026lt;EClass_package\u0026gt;\ropen class \u0026lt;EClass\u0026gt; {\r}\r\r\r\rExample\r\r\rbehavior helloworld;\ropen class HelloWorld {\r}\r\r\r An .ale file can declare only one open class per EClass.\n\rDeclaring a new attribute Creating a variable in the body of an opened in fact adds a new attribute to the weaved EClass. If the feature is a primitive (boolean, int, string, etc.) it is inferred as an EAttribute. Otherwise it is inferred as an EReference.\n\r\rExample\r\r\ropen class FSM {\rState currentState;\roverride void on(String event) {\rif (event = 'right-click') {\rself.currentState := fsm::MoveState.create();\r}\r}\r}\r\r\r The new feature should be runtime specific, such as adding a currentState inside a Finite State Machine.\n\rA multiplicity can be specified to indicate that the attribute represents several values. It follows the following syntax:\n\u0026lt;min\u0026gt;..\u0026lt;max\u0026gt; \u0026lt;type\u0026gt; \u0026lt;name\u0026gt;;\r\u0026lt;min\u0026gt; is the minimum number of values in the attribute.\n\u0026lt;max\u0026gt; is the maximum number of values. * indicates any number of values.\n\u0026lt;type\u0026gt; is the type of the values acceptable in the attribute.\n\u0026lt;name\u0026gt; is the name of the attribute.\n\r\rExample\r\r\ropen class FSM {\r0..* State states;\roverride def addState(State newState) {\rself.states += newState;\r}\rdef void display() {\rfor (State state in self.states) {\rstate.display();\r}\r}\r}\r\r\r Declaring bidirectional references The opposite keyword allows to declare a bidirectional reference. It is equivalent to the EMF opposite relation. It follows the following syntax:\nopposite \u0026lt;var_name_in_opposite_class\u0026gt; \u0026lt;opposite_class\u0026gt; \u0026lt;var_name_in_class\u0026gt;;\r\u0026lt;opposite_class\u0026gt; is the name of the class with which the bidirectional must be set.\n\u0026lt;var_name_in_opposite_class\u0026gt; is the name of the variable holding the reference to the current class in the opposite class.\n\u0026lt;var_name_in_class\u0026gt; is the name of the variable holding the reference in the current EClass.\nAn opposite reference must be declared in both classes.\n\r\r\rExample\r\r\rclass ParentNode {\r// can be accessed with self.child\ropposite parent ChildNode child;\r}\rclass ChildNode {\r// can be accessed with self.parent\ropposite child ParentNode parent;\r}\r\r\r Declaring a set The unique keyword allows to declare a multiplicity-many attribute that should only store unique values. Values are compared thanks to their Java equals method. It is equivalent to the EMF unique feature. It follows the following syntax:\nunique \u0026lt;multiplicity\u0026gt; \u0026lt;type\u0026gt; \u0026lt;var_name\u0026gt;\r\u0026lt;multiplicity\u0026gt; is the multiplicity of the attribute (see declaring a new attribute). It must be a many multiplicity.\n\u0026lt;type\u0026gt; is the type of the elements contained in the collection.\n\u0026lt;var_name\u0026gt; is the name of the variable holding the reference.\n\r\rExample\r\r\rclass Parent {\runique 0..* Child children; }\r\r\r Implementing an EOperation The override keyword allows to implement the behavior of an EOperation declared in the ECore metamodel of the weaved EClass. We call such operations: \u0026ldquo;overridden operations\u0026quot;. It follows the following syntax:\noverride \u0026lt;type\u0026gt; \u0026lt;name\u0026gt;([\u0026lt;param_type\u0026gt; \u0026lt;param_name\u0026gt;]*) {\r\u0026lt;statement\u0026gt;*\r}\r\u0026lt;type\u0026gt; is the type of the value returned by the operation.\n\u0026lt;name\u0026gt; is the name of the operation.\n\u0026lt;param_type\u0026gt; \u0026lt;param_name\u0026gt; define the type and the name of a parameter. Parameters are optional and separated by commas (,).\n\u0026lt;stamement\u0026gt; is an arbitrary number of statements.\nAn overridden operation can only be declared within an open class an must have the exact same signature as an existing EOperation from the weaved EClass or one of its super types.\n\r\r\rExample\r\r\ropen class Circle {\roverride int circumference() {\rdouble PI := 3.14159;\rresult := self.radius * PI * 2;\r}\r}\r{% /unsafeExpand %}\nSee also defining operations for further details about operation syntax.\n\rInheriting open classes The extends keyword allows to extend an open class with another open class.\nWhen writing an Open Class you may want to specialize one (or more) existing open class. The new Open Class reuses all the inherited content, declares new features/operations and refines body of inherited operations.\nThe extended open class have to be weaved on the same EClass (or super type) of the current open class.\nIt follows the following syntax:\nopen class \u0026lt;name\u0026gt; extends \u0026lt;open_class_1\u0026gt;[, \u0026lt;open_class_n\u0026gt;]* {\r}\r\u0026lt;name\u0026gt; is the name of the extending class.\n\u0026lt;open_class_1\u0026gt; is the name of the open class being extended. An open class may inherit from several open classes; in such a case the name of the extended classes must be separated by commas (,).\nAny open class from the same file can be extended.\n\r\r \u0026lt;b\u0026gt;Example\u0026lt;/b\u0026gt;\r\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;expand-content\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\r\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;open class State {\roverride String execute() {\rresult := 'State ' + self.name;\r}\r }\nopen class Initial extends State { override String execute() { result := \u0026lsquo;Initial State ' + self.name; } }  \n\rClasses from other files can be extended too but must be imported first (see importing an existing class).\n\r\r \u0026lt;b\u0026gt;Example\u0026lt;/b\u0026gt;\r\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;expand-content\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\r\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;behavior fsm.composite.executable;\r import fsm.executable as simplefsm;\nopen class CompositeState extends simplefsm.State { override void exec() { // Redefine the behavior here } }  \n\r AQL Some cheatsheets on AQL expressions\nSee AQL syntax reference for more details.\nType of anEPackage.oclIsKindOf(ecore::ENamedElement) //true\ranEPackage.oclIsTypeOf(ecore::ENamedElement) //false\rServices for collections OrderedSet{'a', 'b', 'c'} + OrderedSet{'c', 'b', 'f'}\rSequence{'a', 'b', 'c'}-\u0026gt;any(str | str.size() = 1)\rSequence{'a', 'b', 'c'}-\u0026gt;asOrderedSet()\rOrderedSet{'a', 'b', 'c'}-\u0026gt;asSequence()\rSequence{'a', 'b', 'c', 'c', 'a'}-\u0026gt;asSet()\rSequence{'a', 'b', 'c'}-\u0026gt;at(1)\rSequence{'a', 'b', 'c'}-\u0026gt;collect(str | str.toUpper())\rOrderedSet{'a', 'b', 'c'}-\u0026gt;concat(Sequence{'d', 'e'})\rOrderedSet{'a', 'b', 'c'}-\u0026gt;count('d')\rSequence{'a', 'b', 'c'}-\u0026gt;excludes('a')\rSequence{'a', 'b'}-\u0026gt;excludesAll(OrderedSet{'a','f'})\rOrderedSet{'a', 'b', 'c'}-\u0026gt;excluding('c')\rSequence{'a', 'b', 'c'}-\u0026gt;exists(str | str.size() \u0026gt; 5)\rSequence{anEClass, anEAttribute}-\u0026gt;filter(ecore::EStructuralFeature)\rSequence{'a', 'b', 'c'}-\u0026gt;first()\rSequence{'a', 'b', 'c'}-\u0026gt;forAll(str | str.size() = 1)\rSequence{'a', 'b', 'c'}-\u0026gt;includes('d')\rSequence{'a', 'b', 'c'}-\u0026gt;includesAll(OrderedSet{'a', 'f'})\rOrderedSet{1, 2, 3, 4}-\u0026gt;indexOf(3)\rOrderedSet{'a', 'b', 'c'}-\u0026gt;insertAt(2, 'f')\rOrderedSet{'a', 'b', 'c'}-\u0026gt;intersection(OrderedSet{'a', 'f'})\rOrderedSet{'a', 'b', 'c'}-\u0026gt;isEmpty()\rSequence{'a', 'b', 'c'}-\u0026gt;isUnique(str | str.size())\rSequence{'a', 'b', 'c'}-\u0026gt;last()\rOrderedSet{'a', 'b', 'c'}-\u0026gt;notEmpty()\rSequence{'a', 'b', 'c'}-\u0026gt;one(str | str.equals('a'))\rOrderedSet{'a', 'b', 'c'}-\u0026gt;prepend('f')\rOrderedSet{'a', 'b', 'c'}-\u0026gt;reject(str | str.equals('a'))\rOrderedSet{'a', 'b', 'c'}-\u0026gt;reverse()\rSequence{'a', 'b', 'c'}-\u0026gt;select(str | str.equals('a'))\rSequence{'a', 'b', 'c'}-\u0026gt;sep('[', '-', ']')\rSequence{'a', 'b', 'c'}-\u0026gt;sep('-')\rSequence{'a', 'b', 'c'}-\u0026gt;size()\rSequence{'aa', 'bbb', 'c'}-\u0026gt;sortedBy(str | str.size())\rSequence{'a', 'b', 'c'} - Sequence{'c', 'b', 'f'}\rOrderedSet{'a', 'b', 'c'}-\u0026gt;subOrderedSet(1, 2)\rSequence{'a', 'b', 'c'}-\u0026gt;subSequence(1, 2)\rSequence{1, 2, 3, 4}-\u0026gt;sum()\rSequence{'a', 'b', 'c'}-\u0026gt;union(Sequence{'d', 'c'})\r Misc Calling Java code ALE offers the possibility to call static methods written in Java from the body of an EOperation.\nFor example let\u0026rsquo;s assume that you have a Java class MyService providing the method foo():\npackage some.packagename;\rpublic class MyService {\r// By convention the caller object is the first argument\rpublic static void foo(EObject caller) {\rSystem.out.println(\u0026quot;Foo: \u0026quot;+ caller.eClass().getName());\r}\r}\rYou can call foo() on any EObject just by importing the class MyService with the keyword use at the beginning of your .ale file. The only requirement is that MyService has to be in the classpath of your project.\nuse some.packagename.MyService; //Import external Java services\ropen class FSM {\rdef void callJavaFoo() {\rself.states.forAll(state | state.foo());\r}\r}\rPrinting to the console ALE provides the log() method that can be used on String instances to print themselves to the console.\n\r\r \u0026lt;b\u0026gt;Example\u0026lt;/b\u0026gt;\r\u0026lt;/span\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;div class=\u0026quot;expand-content\u0026quot; style=\u0026quot;display: none;\u0026quot;\u0026gt;\r\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;'Hello World!'.log();\r (\u0026rsquo;\u0026rsquo; + 42).log();  \n\r\r "
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/features/java-api/",
	"title": "Java API",
	"tags": [],
	"description": "",
	"content": "Run the ALE interpreter programmatically The AleInterpreter class provides a public API to interpret ALE scripts.\nIt can be used as follows:\n// Retrieve:\r// - the .dsl file defining the metamodel and its behavior\r// - the .xmi file defining the model to execute\r\rIResource dslFile = ...\rString dslFileLocation = dslFile.getLocationURI().getPath();\rIResource xmiModelFile = ...\rString xmiModelFileLocation = xmiModelFile.getLocation().toString();\r// Initialize the ALE interpreter\r\rList\u0026lt;Object\u0026gt; args = List.of();\rSet\u0026lt;String\u0026gt; plugins = Set.of();\rSet\u0026lt;String\u0026gt; projects = Set.of(dslFile.getProject().getName(), xmiModelFile.getProject().getName());\rALEInterpreter interpreter = new ALEInterpreter();\rinterpreter.javaExtensions.updateScope(plugins,projects);\rinterpreter.javaExtensions.reloadIfNeeded();\r// Run the ALE interpreter\r\rIEvaluationResult result = interpreter.eval(\rxmiModelLocation, args, new WorkbenchDsl(dslFileLocation)\r);\r\rAleInterpreter is defined in the org.eclipse.emf.ecoretools.ale bundle.\n\r"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/getting-started/syntax-overview/",
	"title": "Language overview",
	"tags": [],
	"description": "",
	"content": "ALE is an interpreted, object-oriented and statically typed language. It shares a lot of its syntax with the Acceleo Query Language (AQL) that it actually uses under the hood.\nA comprehensive guide of ALE\u0026rsquo;s syntax can be found in the Reference chapter.\n\rObject-Oriented Classes In ALE, classes can be defined with the class keyword:\nclass Sun {\r}\rA corresponding EClass is created at runtime by ALE\u0026rsquo;s interpreter. The open keyword must be used to refer to an EClass that already exist in the Ecore model:\nopen class ENamedElement {\r}\rA class can be instantiated with the create() service:\nHelloWorld hello := helloworld::HelloWorld.create();\rMethods Methods are declared with the def keyword:\nopen class Sun {\rdef void shine() {\r}\r}\rTo override an EOperation defined in an Ecore model the override keyword must be used instead:\nopen class Sun {\roverride int radius() {\rresult := 696340;\r}\r}\rIn ALE there is no return keyword. Instead, each method has a special result variable that represents its return value. := is the affectation operator whereas = is used to check equality.\nThe self keyword is used to reference the current object:\nopen class User {\roverride String getFullName() {\rresult := self.firstname + ' ' + self.lastname;\r}\r}\rAttributes Attributes can be declared within a class as follows:\nclass User {\rint age;\rString name := 'Unknown';\r}\rThe following table shows all the built-in types:\n   Type Description Instantiation     Integer A number without decimal part int a := 12   Real A number with decimal part double r := 23.5   String A sequence of characters String str := 'Hello World!'   Boolean Either true of false boolean b := true   Sequence An ordered collection of elements Sequence(Integer) numbers = Sequence{1, 2, 3}   OrderedSet An ordered collection of unique elements OrderedSet(String) users = OrderedSet{'Foo', 'Bar'}    Conclusion Now that we covered the basics of ALE you\u0026rsquo;re ready to go further with the MiniFsm tutorial.\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Tutorials Follow the guide to unveil ALE\u0026rsquo;s full potential.\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Reference Comprehensive documentation of ALE\u0026rsquo;s syntax and concepts.\n"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/features/compilation-to-java/",
	"title": "Compilation to Java",
	"tags": [],
	"description": "",
	"content": "ALE Compiler The Action Language for EMF Compiler (ALEC) allows to compile ALE source files as Java code for better performances and integration with existing tools.\nMain features  Integration with Eclipse IDE: compile ALE behaviors in the Eclipse IDE Maven integration: automatically compile your behaviors using the ALE compiler Maven plugin Configurable: the ALE Compiler can target four implementation patterns: Interpreter, Visitor, EMFâ€™s Switch and Revisitor  Prerequisites At the moment ALEC is not embedded within ALE and must be installed separately. To this end:\n Help \u0026gt; Install New Software... Fill the Work with field with the update site\u0026rsquo;s URL:  http://www.kermeta.org/ale-lang-compiler/updates/latest/   Hit Enter and wait for the list to load Check Action Language EMF Compiler Click Next then Finish  Archived versions of ALEC can be found under http://www.kermeta.org/ale-lang-compiler/updates/\n\rCompilation from the Eclipse IDE  Create a new ALE project with a metamodel and some behavior Open the .dsl file and add the following line: compilationType=interpreter\r Right-click on the .dsl file then ALE \u0026gt; Generate Ale Implementation A compiled version of the ALE behavior should have been generated in the interpreter-comp/ directory.  This compiled version is implemented with the Interpreter pattern. By substituing interpreter for visitor, switch or revisitor on step â‘¡ you can freely compile to another implementation pattern.\nCompilation with Maven We do not cover the details of the integration of you project using maven but several example of ALE projects with a Maven integration can be found in the ALE Compiler repository.\n\rTo execute ALEC as part of your Maven builds you have to add the alecompiler-maven-plugin to your project\u0026rsquo;s POM:\n\u0026lt;build\u0026gt;\r\u0026lt;sourceDirectory\u0026gt;${pattern}-comp\u0026lt;/sourceDirectory\u0026gt;\r\u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.eclipse.emf.ecoretools.ale.compiler\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;alecompiler-maven-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;executions\u0026gt;\r\u0026lt;execution\u0026gt;\r\u0026lt;phase\u0026gt;generate-sources\u0026lt;/phase\u0026gt;\r\u0026lt;goals\u0026gt;\r\u0026lt;goal\u0026gt;ale-dsl-compile\u0026lt;/goal\u0026gt;\r\u0026lt;/goals\u0026gt;\r\u0026lt;/execution\u0026gt;\r\u0026lt;/executions\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;dslFile\u0026gt;${project.basedir}/src/${metamodel.name}.dsl\u0026lt;/dslFile\u0026gt;\r\u0026lt;/configuration\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r\u0026lt;/build\u0026gt;\r"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Action Language for EMF The Action Language for EMF (ALE) is a language used to make Ecore metamodels executable. Define the behavior of your models in a dedicated, interpreted and object-oriented language and run it in minutes!\nWith ALE, you can execute your models right from your IDE: you no longer need to spend time generating and tweaking Java code!\n\rMain features  Executable metamodeling: re-open existing EClasses to insert new methods with their implementations Metamodel extension: the very same mechanism can be used to extend existing Ecore metamodels and insert new features (eg. attributes) in a non-intrusive way Interpreted: no need to deploy Eclipse plugins, just run the behavior on a model directly in your modeling environment Extensible: if ALE doesn\u0026rsquo;t fit your needs, register Java classes as services and invoke them directly from ALE  Breathe life into your metamodels! ALE makes it easy to address a wide range of activities related to model elements manipulation. This includes activities such as:\n weaving operational semantics in metamodel definitions, defining model checkers, defining model-to-model transformations, defining model-to-text transformations.  Open-class mechanism The following ALE snippet defines the behavior of an FSM:\nbehavior fsm.dummy.implementation;\ropen class FSM {\rState currentState;\rString currentEvent;\roverride void execute(EList\u0026lt;String\u0026gt; events) {\r'Start'.log();\rself.currentState := self.initialState;\rfor(event in events) {\rself.currentState.execute();\rself.currentState :=\rself.currentState.transitions\r-\u0026gt;select(t | t.event = self.currentEvent)\r-\u0026gt;first();\r}\r'End'.log();\r}\r}\r"
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://echebbi.github.io/ale-lang-docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]